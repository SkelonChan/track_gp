function [sys,x0,str,ts] = mpc08522(t,x,u,flag)
% 该程序功能：用LTVMPC 和车辆简化动力学模型（小角度假设）设计控制器，作为Simulink的控制器
% 程序版本 V1.0，MATLAB版本：R2019a,采用S函数的标准形式，
% Q_40*40,R_5*5,a_6*6,b_6*1,d_k 6*1,A_7*7,B_7*1,C_2*7
% Nx=6;%状态量的个数；Nu=1;%控制量的个数；Ny=2;%输出量的个数；Np =20;%预测时域；Nc=5;%控制时域
% 状态量=[y_dot,x_dot,phi,phi_dot,Y,X]，控制量为前轮偏角delta_f
%本章利用离散线性化第二种方法基于状态轨迹的线性化方法，在进行下一时刻状态空间预测的时候，并没有用到状态量误差矩阵而是用多出来的一项偏差d_k来表示，与第四章有所不同，博客上有详细介绍。
switch flag,
 case 0
  [sys,x0,str,ts] = mdlInitializeSizes; % Initialization
 case 2
  sys = mdlUpdates(t,x,u); % Update discrete state 
 case 3
  sys = mdlOutputs(t,x,u); % Calculate outputs
 case {1,4,9} % Unused flags
  sys = [];
 otherwise
  error(['unhandled flag = ',num2str(flag)]); % Error handling
end
% End of dsfunc.

%==============================================================
% Initialization
%==============================================================

function [sys,x0,str,ts] = mdlInitializeSizes

% Call simsizes for a sizes structure, fill it in, and convert it 
% to a sizes array.

sizes = simsizes;
sizes.NumContStates  = 0;
sizes.NumDiscStates  = 6;
sizes.NumOutputs     = 6;
sizes.NumInputs      = 17;%%如果加上gp此处应该为17.不加gp为11
sizes.DirFeedthrough = 1; % Matrix D is non-empty.
sizes.NumSampleTimes = 1;
sys = simsizes(sizes); 
x0 =[0.001;0.0001;0.0001;0.00001;0.00001;0.00001];    
global U;%U为我们的控制量
U=[0 ];%控制量初始化,这里面加了一个期望轨迹的输出，如果去掉，U为一维的

% Initialize the discrete states.
str = [];             % Set str to an empty matrix.
 ts  = [0 0];        % sample time: [period, offset]，采样时间影响最大使用连续采样
%End of mdlInitializeSizes
global VehiclePara; 
    VehiclePara.m   = 2298.44;   %m为车辆质量,Kg; Sprung mass = 1370
    VehiclePara.g   = 9.8;
    VehiclePara.Lf  = 1.33;  % 1.05
    VehiclePara.Lr  = 1.81;  % 1.55
    VehiclePara.L   = 2.33;  %VehiclePara.Lf + VehiclePara.Lr;
    VehiclePara.Iz  = 7152;   %I为车辆绕Z轴的转动惯量，车辆固有参数  
    VehiclePara.Ccf  = 66900;
    VehiclePara.Ccr  = 62700;
    VehiclePara.Clf  = 66900;
    VehiclePara.Clr  = 62700;
global times;
times = 0;
global MPCParameter; 
    MPCParameter.Ts  = 0.02; % 	仿真步长      
%==============================================================
% Update the discrete states
%==============================================================
function sys = mdlUpdates(t,x,u)
  
sys = x;
%End of mdlUpdate.

%==============================================================
% Calculate outputs
%==============================================================
function sys = mdlOutputs(t,x,u)
     global a b; %设置a,b矩阵为全局量
     global VehiclePara;
     global MPCParameter;
     global U; %设置U为全局量
%      global times;
%      times = times+1
    tic
    Nx=6;%状态量的个数
    Nu=1;%控制量的个数
    Ny=2;%输出量的个数
    Np =10;%预测时域
    Nc=4;%控制时域
    Row=10000;%松弛因子权重
    fprintf('Update start, t=%6.3f\n',t)
    %% 加载路径数据
    load ref11
%     load gpdata
    %%
    T=0.02;%仿真步长
   %输入接口转换,x_dot后面加一个非常小的数，是防止出现分母为零的情况，这与我们建立的状态量的顺序一致。
   %以下为我们的状态量误差矩阵，由于我们的初始值给的很小，这里予以忽略
    y_dot=u(1)/3.6; %横向速度化为m/s
    x_dot=u(2)/3.6+0.0001;%CarSim输出的是km/h，转换为m/s
    phi=u(3)*3.141592654/180; %CarSim输出的为角度，角度转换为弧度，编程时我们都是使用弧度
    phi_dot=u(4)*3.141592654/180;%角速度
    Y=u(5);%单位为m，横向位置
    X=u(6);%单位为米，纵向位置
    Sf=u(7);%左前轮滑移率
    Sr=u(8);%右前轮滑移率
%     gpmean_vy = u(12);
%     gpmean_vx = u(13);
%     gpmean_yaw_rate = u(14);
%     gpmean_yaw = u(15);
%     gpcov_vy = u(16);
%     gpcov_yaw_rate = u(17);
%% 车辆参数输入
%syms sf为前轮滑移率，sr为后轮滑移率
%     Sf=0.2; Sr=0.2;
%syms lf%前轮距离车辆质心的距离，lr为后轮距离车辆质心的距离
    lf=1.33;lr=1.81;
%syms C_cf前轮线性横向侧偏刚度； C_cr后轮线性横向侧偏刚度 ；C_lf 前轮纵向侧偏刚度； C_lr 后轮纵向侧偏刚度
    Ccf=66900;Ccr=62700;Clf=66900;Clr=62700;
%syms m g I;%m为车辆质量，g为重力加速度，I为车辆绕Z轴的转动惯量，车辆固有参数
    m=2298;g=9.8;I=7152;
   

%% 参考轨迹生成
    X_predict=zeros(Np,1);%用于保存预测时域内的纵向位置信息，这是计算期望轨迹的基础
    phi_ref=zeros(Np,1);%用于保存预测时域内的参考横摆角信息
    Y_ref=zeros(Np,1);%用于保存预测时域内的参考横向位置信息

%     times = ceil(t/0.01)+1;
%     %  以下计算状态量，即状态量与控制量合在一起 
%     fprintf('time is ,%f\n',times);
    
    kesi=zeros(Nx+Nu,1);%状态量6个，控制量1个
    kesi(1)=y_dot;%
    kesi(2)=x_dot;
    kesi(3)=phi; 
    kesi(4)=phi_dot;
    kesi(5)=Y;
    kesi(6)=X; %以上6个为我们的状态量
    kesi(7)=U(1); %这个是控制量前轮偏角，即在轨迹跟踪过程中通过对前轮偏角进行控制，纵向速度保持不变
    delta_f=U(1);%前轮转角,必须要有
    fprintf('Update start, u(1)=%4.2f\n',U(1))   
    %权重矩阵设置 
    Q_cell=cell(Np,Np);%总的元胞Q为20行20列的，40*40
    for i=1:1:Np 
        for j=1:1:Np
            if i==j
               Q_cell{i,j}=[2000 0;0 10000;];
%                  Q_cell{i,j}=[300 0;0 100;]; %作用是将方阵对角线的地方设置为该矩阵，其余为止全部为0
            else 
                Q_cell{i,j}=zeros(Ny,Ny);    %20行20列的矩阵中每一个小的位置上都是2*2的小矩阵           
            end
        end 
    end 
   Q=cell2mat(Q_cell); %总的元胞Q为20行20列的，每个位置都是2*2的小矩阵，Q最终为40*40
   R=5*10^2*eye(Nu*Nc);
    %最基本也最重要的矩阵，是控制器的基础，采用动力学模型，该矩阵与车辆参数密切相关，通过对动力学方程求解雅克比矩阵得到，a为6*6，b为6*1
     [a, b] = func_Model_linearization_Jacobian(kesi,Sf,Sr,MPCParameter,VehiclePara);
%         a=[                 1 - (259200*T)/(1723*x_dot),                                                         -T*(phi_dot + (2*((460218*phi_dot)/5 - 62700*y_dot))/(1723*x_dot^2) - (133800*((154*phi_dot)/125 + y_dot))/(1723*x_dot^2)),                                    0,                     -T*(x_dot - 96228/(8615*x_dot)), 0, 0
%         T*(phi_dot - (133800*delta_f)/(1723*x_dot)),                                                                                                                  (133800*T*delta_f*((154*phi_dot)/125 + y_dot))/(1723*x_dot^2) + 1,                                    0,           T*(y_dot - (824208*delta_f)/(8615*x_dot)), 0, 0
%                                                   0,                                                                                                                                                                                  0,                                    1,                                                   T, 0, 0
%             (33063689036759*T)/(7172595384320*x_dot), T*(((2321344006605451863*phi_dot)/8589934592000 - (6325188028897689*y_dot)/34359738368)/(4175*x_dot^2) + (5663914248162509*((154*phi_dot)/125 + y_dot))/(143451907686400*x_dot^2)),                                   0, 1 - (813165919007900927*T)/(7172595384320000*x_dot), 0, 0
%                                           T*cos(phi),                                                                                                                                                                         T*sin(phi),  T*(x_dot*cos(phi) - y_dot*sin(phi)),                                                   0, 1, 0
%                                          -T*sin(phi),                                                                                                                                                                         T*cos(phi), -T*(y_dot*cos(phi) + x_dot*sin(phi)),                                                   0, 0, 1];
%    
%     b=[                                                               133800*T/1723
%        T*((267600*delta_f)/1723 - (133800*((154*phi_dot)/125 + y_dot))/(1723*x_dot))
%                                                                                  0
%                                                 5663914248162509*T/143451907686400
%                                                                                  0
%                                                                                  0];  
    d_k=zeros(Nx,1);%计算偏差,6*1
    state_k1=zeros(Nx,1);%预测下一时刻状态量，用于计算偏差，6*1
    %以下即为根模型据离散非线性预测下一时刻状态量
%     gpmean_vy = gpdata(times,1);
%     gpmean_vx = gpdata(times,2);
%     gpmean_yaw_rate = gpdata(times,3);
    %  系统下一时刻状态量
%     state_k1(1,1)=y_dot+T*(-x_dot*phi_dot+2*(Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)+Ccr*(lr*phi_dot-y_dot)/x_dot)/m+(t>2.5&&t<6)*gpmean_vy+(t>8)*gpmean_vy)+(t>=6&&t<=8)*gpmean_vy+(t<=2.5)*gpmean_vy;
% %     state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr-Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m);
%     state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr+Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m+(t>2.5&&t<6)*gpmean_vx+(t>8)*gpmean_vx)+(t>=6&&t<=8)*gpmean_vx+(t<=2.5)*gpmean_vx;
%     state_k1(3,1)=phi+T*(phi_dot);
%     state_k1(4,1)=phi_dot+T*((2*lf*Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)-2*lr*Ccr*(lr*phi_dot-y_dot)/x_dot)/I+(t>2.5&&t<6)*gpmean_yaw_rate+(t>8)*gpmean_yaw_rate)+(t>=6&&t<=8)*gpmean_yaw_rate+(t<=2.5)*gpmean_yaw_rate;
%     state_k1(5,1)=Y+T*(x_dot*sin(phi)+y_dot*cos(phi));
%     state_k1(6,1)=X+T*(x_dot*cos(phi)-y_dot*sin(phi)); %到此为止，下一时刻的状态量已经推导完毕
    
%     state_k1(1,1)=y_dot+T*(-x_dot*phi_dot+2*(Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)+Ccr*(lr*phi_dot-y_dot)/x_dot)/m+gpmean_vy);
% %     state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr-Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m);
%     state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr+Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m+gpmean_vx);
%     state_k1(3,1)=phi+T*phi_dot;
%     state_k1(4,1)=phi_dot+T*((2*lf*Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)-2*lr*Ccr*(lr*phi_dot-y_dot)/x_dot)/I+gpmean_yaw_rate);
%     state_k1(5,1)=Y+T*(x_dot*sin(phi)+y_dot*cos(phi));
%     state_k1(6,1)=X+T*(x_dot*cos(phi)-y_dot*sin(phi)); %到此为止，下一时刻的状态量已经推导完毕

    state_k1(1,1)=y_dot+T*(-x_dot*phi_dot+2*(Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)+Ccr*(lr*phi_dot-y_dot)/x_dot)/m);
%     state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr-Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m);
    state_k1(2,1)=x_dot+T*(y_dot*phi_dot+2*(Clf*Sf+Clr*Sr+Ccf*delta_f*(delta_f-(y_dot+phi_dot*lf)/x_dot))/m);
    state_k1(3,1)=phi+T*phi_dot;
    state_k1(4,1)=phi_dot+T*((2*lf*Ccf*(delta_f-(y_dot+lf*phi_dot)/x_dot)-2*lr*Ccr*(lr*phi_dot-y_dot)/x_dot)/I);
    state_k1(5,1)=Y+T*(x_dot*sin(phi)+y_dot*cos(phi));
    state_k1(6,1)=X+T*(x_dot*cos(phi)-y_dot*sin(phi)); %到此为止，下一时刻的状态量已经推导完毕
    %% +Bc dk
    d_k=state_k1-a*kesi(1:6,1)-b*kesi(7,1);%求偏差矩阵d_k，见论文式（15a)
   % d_k=state_k1;
    d_piao_k=zeros(Nx+Nu,1);%偏差矩阵d_k的增广形式，又加了控制量的那一行，维度7*1参考falcone(B,4c)
    d_piao_k(1:6,1)=d_k; %给d_k的增广形式进行赋值，前6行为我们的偏差
    d_piao_k(7,1)=0;%最后一行为我们的控制量
    
    A_cell=cell(2,2);
    B_cell=cell(2,1);
    A_cell{1,1}=a;%第一行第一列6*6
    A_cell{1,2}=b;%第一行第二列为6*1
    A_cell{2,1}=zeros(Nu,Nx);%第二行第一列为1*6
    A_cell{2,2}=eye(Nu);%最二行第二列为1*1
    B_cell{1,1}=b;%B矩阵第一行第一列为b,6*1
    B_cell{2,1}=eye(Nu);%第二行第一列为1*1单位阵
    %A=zeros(Nu+Nx,Nu+Nx);
    A=cell2mat(A_cell);%A矩阵维度7*7
    B=cell2mat(B_cell);%B矩阵维度7*1
    C=[0 0 1 0 0 0 0;0 0 0 0 1 0 0;];%我们只输出状态看空间的第三个量（横摆角）和第五个量（横向偏移量）
    %以下矩阵的求法见论文式（21）
    PSI_cell=cell(Np,1);%输出方程的第一个系数矩阵，维度 20*1
    THETA_cell=cell(Np,Nc);%输出方程的第二个系数矩阵，维度 20*5
    GAMMA_cell=cell(Np,Np);%维度 20*20
    PHI_cell=cell(Np,1);%维度 20*1
    %构造论文中式（21）的第三部分
    for p=1:1:Np
        PHI_cell{p,1}=d_piao_k;%  7行1列的偏差，理论上来说，这个是要实时更新的，但是为了简便，这里又一次近似
        for q=1:1:Np 
            if q<=p  %下三角矩阵
                GAMMA_cell{p,q}=C*A^(p-q); %该矩阵由C和A构造而成
            else 
                GAMMA_cell{p,q}=zeros(Ny,Nx+Nu); %每一个元胞的大小为2（输出两个数）*7（状态空间量的个数）
            end 
        end
    end  %最终该矩阵为40*140
    %构造论文中式（21）的第
    for j=1:1:Np %j从1到20
     PSI_cell{j,1}=C*A^j; %构造输出方程式（21）中第一项的系数矩阵，2*7*7*7=2*7
        for k=1:1:Nc %k从1到5，构造输出方程式（21）中第二项的系数矩阵
            if k<=j  %下三角的区域有值
                THETA_cell{j,k}=C*A^(j-k)*B;  
            else %上三角区域全部为0
                THETA_cell{j,k}=zeros(Ny,Nu); %每一个小元胞都是2*1小矩阵
            end
        end
    end
     %论文中式（21）的前两项的系数矩阵，PSI为状态空间kesi的系数矩阵，THETA为控制增量的系数矩阵
    PSI=cell2mat(PSI_cell);%size(PSI)=[Ny*Np Nx+Nu]，共20行1列，每一个小元胞都是2*7的小矩阵，所以为40*7
    THETA=cell2mat(THETA_cell);%size(THETA)=[Ny*Np Nu*Nc]，40*5
    %论文中式（21）的第三部分
    GAMMA=cell2mat(GAMMA_cell);%大写的GAMMA；维度40*140
    PHI=cell2mat(PHI_cell);%由于该元胞数组每一个位置都是7*1的矩阵，一共20行，所以一共是140*1
    %144行已经求得Q元胞数组，现在将其转换成矩阵形式
    Q=cell2mat(Q_cell); %总的元胞Q为20行20列的，每个位置都是2*2的小矩阵，Q最终为40*40
    %构造二次规划的H矩阵
    H_cell=cell(2,2);
    H_cell{1,1}=THETA'*Q*THETA+R;%第一行第一列的位置为5*5的矩阵
    H_cell{1,2}=zeros(Nu*Nc,1);%第一行第二列的位置为5*1
    H_cell{2,1}=zeros(1,Nu*Nc);%第二行第一列的位置为1*5
    H_cell{2,2}=Row;%第二行第二列为一个值：松弛因子
    H=cell2mat(H_cell);%构造完毕之后将H元胞数组转化为矩阵，最终为H为6*6
    H=(H+H')/2;
    error_1=zeros(Ny*Np,1);%40*7*7*1=40*1
    Yita_ref_cell=cell(Np,1);%参考的元胞数组为20*1
%     
   
    for p=1:1:Np
        X_DOT=x_dot*cos(phi)-y_dot*sin(phi);%惯性坐标系下纵向速度
        X_predict(p,1)=X+X_DOT*p*T;%首先计算出未来X的位置，
        %参考路径信息包括参考的纵向位置，横向位置，横摆角
        last=size(ref11,1);
        pt = ref11(:,1);
        if X_predict(p,1)>=ref11(last,2)
%             Y_ref(p,1)=path66(last,6);
%             phi_ref(p,1)=path66(last,7);
            Y_ref(p,1)=0;
            phi_ref(p,1)=0;
            Yita_ref_cell{p,1}=[phi_ref(p,1);Y_ref(p,1)];
        else
            x_refer=ref11(:,2); %设置的纵向位移
            y_refer=ref11(:,3); %设置的横向位移
            phi_refer=ref11(:,4);
            Y_ref(p,1)=interp1(pt,y_refer,t+(i-1)*T);
            phi_ref(p,1)=interp1(pt,phi_refer,t+(i-1)*T);
            Yita_ref_cell{p,1}=[phi_ref(p,1);Y_ref(p,1)];
        end
    end
    
    v_y_vector = ref11(:,7);
    yaw_rate_vector = ref11(:,5);
    phi_rate = interp1(pt,yaw_rate_vector,t);
    v_y = interp1(pt,v_y_vector,t);
    
    Yita_ref=cell2mat(Yita_ref_cell);%将我们得到的输出元胞转换为矩阵
    error_1=Yita_ref-PSI*kesi-GAMMA*PHI; %求偏差，论文中公式（23）下面有，因为要构造二次规划的f矩阵，所以必须求它。
    g_cell=cell(1,2);%还是见论文公式（23）下面。
    g_cell{1,1}=2*error_1'*Q*THETA;
    g_cell{1,2}=0;
    g=-cell2mat(g_cell);
    f=g';%矩阵部分一律按照我们的ppt推导来进行学习
    
 %% 以下为约束生成区域
 %控制量约束
    A_t=zeros(Nc,Nc);%见falcone论文 P181
    for p=1:1:Nc
        for q=1:1:Nc
            if q<=p %下三角矩阵包含对角线
                A_t(p,q)=1;
            else 
                A_t(p,q)=0;
            end
        end 
    end 
    A_I=kron(A_t,eye(Nu));%求克罗内克积
    Ut=kron(ones(Nc,1),U(1));
    
    umin=-0.1744;%维数与控制变量的个数相同，前轮偏角的上约束
    umax=0.1744;%前轮偏角的下约束
    Umin=kron(ones(Nc,1),umin);
    Umax=kron(ones(Nc,1),umax);
    
    %输出量约束
    ycmax=[0.3;6];  %横摆角和横向位移的约束
    ycmin=[-0.3;0];
    Ycmax=kron(ones(Np,1),ycmax);
    Ycmin=kron(ones(Np,1),ycmin);
    
    %二次规划A矩阵
    A_cons_cell={A_I zeros(Nu*Nc,1);-A_I zeros(Nu*Nc,1);THETA zeros(Ny*Np,1);-THETA zeros(Ny*Np,1)};
    A_cons=cell2mat(A_cons_cell);%（求解方程）状态量不等式约束增益矩阵，转换为绝对值的取值范围
    %二次规划的b矩阵
    b_cons_cell={Umax-Ut;-Umin+Ut;Ycmax-PSI*kesi-GAMMA*PHI;-Ycmin+PSI*kesi+GAMMA*PHI};
    b_cons=cell2mat(b_cons_cell);%（求解方程）状态量不等式约束的取值
    
    %控制增量约束
    M=10; 
    delta_umin=-0.0148;%前轮偏角变化量的下约束
    delta_umax=0.0148;%前轮偏角变化量的上约束
    delta_Umin=kron(ones(Nc,1),delta_umin);
    delta_Umax=kron(ones(Nc,1),delta_umax);
    lb=[delta_Umin;0];%（求解方程）状态量下界，包含控制时域内控制增量和松弛因子
    ub=[delta_Umax;M];%（求解方程）状态量上界，包含控制时域内控制增量和松弛因子
    
    %% 开始求解过程
%    options = optimset('Algorithm','interior-point-convex');
    options = optimset('Display','off', ...
        'TolFun', 1e-8, ...
        'MaxIter', 2000, ...
        'Algorithm', 'interior-point-convex', ...
        'FinDiffType', 'forward', ...
        'RelLineSrchBnd', [], ...
        'RelLineSrchBndDuration', 1, ...
        'TolConSQP', 1e-8);
    warning off all  % close the warnings during computation
    x_start=zeros(Nc+1,1);%加入一个起始点
    [X,fval,exitflag]=quadprog(H,f,A_cons,b_cons,[],[],lb,ub,x_start,options);
    fprintf('exitflag=%d\n',exitflag);
    fprintf('H=%4.2f\n',H(1,1));
    fprintf('f=%4.2f\n',f(1,1));
    %% 计算输出
    if (1 ~= exitflag) %if optimization NOT succeeded.
                X(1) = 0.0;
                fprintf('MPC solver not converged!\n');                  
    end

    fprintf("X(1)=%4.2f\n",X(1));
    u_piao=X(1);%得到控制增量
    U(1)=kesi(7,1)+u_piao;%当前时刻的控制量为上一刻时刻控制+控制增量
    %U(1)=u_piao;
    OUT(1)=U(1);
    y_refers=interp1(pt,y_refer,t);
    x_refers=interp1(pt,x_refer,t);
    phi_refers=interp1(pt,phi_refer,t);
    OUT(2) =y_refers;
    OUT(3) = x_refers;
    OUT(4)=phi_refers*180/pi;
%%除以周期/0.000526260393642774
    OUT(5) = phi_rate*180/pi;
    OUT(6) = v_y;

    sys= OUT;
    toc
    
